# APCS 201603-1 成績指標 解題報告

## 題目理解
這題要求處理學生的考試成績，主要需要完成三個任務：
1. 將所有成績由小到大排序輸出
2. 找出不及格（<60分）中的最高分數
3. 找出及格（≥60分）中的最低分數

特殊情況處理：
- 若全班都及格（沒有不及格成績），輸出「best case」
- 若全班都不及格（沒有及格成績），輸出「worst case」

## 解題思路演進

### 初始想法（最小差法）
我最開始的想法是：
1. 先將所有成績排序
2. 計算每個成績與60分的絕對差值
3. 找出差值最小的成績
   - 若該成績<60，則為不及格最高分
   - 若該成績≥60，則為及格最低分

**遇到的問題**：
- 當有兩個成績與60的差值相同時（如58和62），難以判斷該取哪一個
- 無法處理全班都及格或都不及格的情況
- 邏輯過於複雜且容易出錯

### 改進後的思路（邊界查找法）
經過思考後，我發現更簡單有效的方法：
1. 先將所有成績排序
2. **找不及格最高分**：
   - 從排序後的陣列末端往前找第一個<60的成績
   - 若找不到，輸出「best case」
3. **找及格最低分**：
   - 從排序後的陣列開頭往後找第一個≥60的成績
   - 若找不到，輸出「worst case」

**優點**：
- 邏輯簡單直觀
- 能正確處理邊界情況
- 時間效率高（O(n)查找）

## 關鍵演算法說明

### 排序部分
- 使用泡沫排序（Bubble Sort）實現
- 雖然時間複雜度為O(n²)，但因n≤20（題目限制），完全足夠
- 排序後方便後續的邊界查找

### 邊界查找部分
#### 不及格最高分查找
1. 從陣列最後一個元素開始往前檢查
2. 找到第一個分數<60的元素即為所求
3. 若遍歷完整個陣列都找不到，表示全班都及格

#### 及格最低分查找
1. 從陣列第一個元素開始往後檢查
2. 找到第一個分數≥60的元素即為所求
3. 若遍歷完整個陣列都找不到，表示全班都不及格

## 特殊情況處理

### 全班都及格
- 不及格查找會失敗
- 輸出「best case」
- 及格最低分就是排序後的第一個≥60的成績

### 全班都不及格
- 及格查找會失敗
- 輸出「worst case」
- 不及格最高分就是排序後的最後一個<60的成績

## 測試案例分析

### 一般情況測試
**輸入**：
```
5
50 65 40 70 55
```
**處理過程**：
1. 排序後：40 50 55 65 70
2. 不及格最高分：從後往前找，55
3. 及格最低分：從前往後找，65

**輸出**：
```
40 50 55 65 70
55
65
```

### 邊界情況測試
**輸入1（全班及格）**：
```
3
60 75 80
```
**輸出**：
```
60 75 80
best case
60
```

**輸入2（全班不及格）**：
```
4
45 50 55 30
```
**輸出**：
```
30 45 50 55
55
worst case
```

## 時間複雜度分析

1. **排序階段**：
   - 泡沫排序：O(n²)
   - 但n最大為20，所以最多400次操作，非常快速

2. **查找階段**：
   - 兩個方向的線性查找：各O(n)
   - 總共約40次操作（n=20時）


## 心得與改進

### 從錯誤中學習
最初想用「最小差法」是一個過度複雜的想法，實際上：
- 不需要計算與60的差值
- 直接利用排序後的特性就能簡單找到邊界值
- 特殊情況的處理也更直觀

### 可能的改進方向
1. **使用更高效排序**：
   - 雖然泡沫排序足夠，但可以改用內建的sort函數
   - 時間複雜度可降為O(n log n)

2. **代碼優化**：
   - 可以將查找部分寫成函數
   - 減少重複代碼

3. **輸入驗證**：
   - 增加對輸入成績範圍的檢查（0~100分）

## 總結
這題教會我：
- 有時候最直觀的解法就是最好的解法
- 不要過度設計解決方案
- 善用數據排序後的特性可以簡化問題
- 邊界條件檢查的重要性

透過這題的練習，我更加熟悉了基礎的排序和查找操作，也學到了如何選擇合適的演算法來解決問題。